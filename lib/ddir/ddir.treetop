require 'treetop/runtime'

grammar DayDreamInRuby
  rule body
    exprs:expressions {
      def to_ast(context)
        Ddir::Ast::Body.new expressions: exprs.to_ast(context)
      end
    }
  end

  rule expressions
    (indentation expression sp? nl?)* {
      def to_ast(context)
        context.push_expressions do
          elements.each do |el|
            context.update_depth el.indentation.depth
            child = el.expression.to_ast(context)
            context.current_expression.children << child
          end
        end
      end
    }
  end

  rule indentation
    ' '* {
      def depth
        text_value.length / 2
      end
    }
  end

  rule expression
    head:(entry_location / variable / self / integer / symbol)
    tail:expression_modifier* {
      def to_ast(context)
        tail.elements.inject head.to_ast(context) do |ast, modifier|
          modifier.to_ast context, ast
        end
      end
    }
  end

  rule expression_modifier
    sp? modifier:(
      binary_op_call
    / send_assignemnt_message
    / send_message
    / assignment
    / multiline_expression_modifier
    ) {
      def to_ast(context, to_modify)
        modifier.to_ast context, to_modify
      end
    }
  end

  rule multiline_expression_modifier
    nl indentation modifier:send_message {
      def to_ast(context, to_modify)
        context.update_depth indentation.depth
        modifier.to_ast context, to_modify
      end
    }
  end

  rule assignment
    '<-' sp? value:expression {
      def to_ast(context, target_ast)
        Ddir::Ast::Assignment.new target: target_ast, value: value.to_ast(context)
      end
    }
  end

  rule send_assignemnt_message
    '.' name:identifier sp? assignment {
      def to_ast(context, receiver_ast)
        Ddir::Ast::SendMessage.new \
          receiver:  receiver_ast,
          name:      :"#{name.text_value}=",
          arguments: [assignment.value.to_ast(context)], # args
          block:     nil                                 # no block
      end
    }
  end

  rule send_message
    "." name:identifier suffix:('!' / '?' / '') args:(sp expression)* sp? maybe_block:block? {
      def to_ast(context, receiver_ast)
        Ddir::Ast::SendMessage.new \
          receiver:  receiver_ast,
          name:      (name.text_value + suffix.text_value).intern,
          arguments: args.elements.map { |arg| arg.expression.to_ast context },
          block:     (maybe_block.to_ast context unless maybe_block.empty?)
      end
    }
  end

  rule block
    '(' params ')' nl indentation  body:expressions {
      def to_ast(context)
        context.update_depth indentation.depth
        Ddir::Ast::Block.new param_names: params.ordered_names, body: body.to_ast(context)
      end
    }
    /
    nl indentation body:expressions {
      def to_ast(context)
        context.update_depth indentation.depth
        Ddir::Ast::Block.new param_names: [], body: body.to_ast(context)
      end
    }
    /
    '(' params ')' sp? body:expression?  {
      def to_ast(context)
        body_ast = body.empty? ? Ddir::Ast::None.new : body.to_ast(context)
        Ddir::Ast::Block.new param_names: params.ordered_names, body: body_ast
      end
    }
  end

  rule params
    first_name:local_variable?
    remaining_names:(sp? ',' sp? local_variable)* {
      def ordered_names
        names = []
        names << first_name.text_value.intern unless first_name.empty?
        remaining_names.elements.each { |n| names << n.local_variable.text_value.intern }
        names
      end
    }
  end

  rule entry_location
    '->' sp? name:symbol? sp? body:block {
      def to_ast(context)
        name_symbol = name.empty? ? :call : name.to_ast.value(context)
        Ddir::Ast::EntryLocation.new name: name_symbol, body: body.to_ast(context)
      end
    }
  end

  rule binary_op_call
    operator sp? rhs:expression {
      def to_ast(context, lhs)
        Ddir::Ast::BinaryExpression.new left_child:  lhs,
                                        operator:    operator.text_value,
                                        right_child: rhs.to_ast(context)
      end
    }
  end

  rule self
    "@" {
      def to_ast(context)
        Ddir::Ast::Self.new
      end
    }
  end

  rule variable
    variable:(local_variable / instance_variable) {
      def to_ast(context)
        variable.to_ast(context)
      end
    }
  end

  rule local_variable
    identifier {
      def to_ast(context)
        Ddir::Ast::LocalVariable.new name: text_value.intern
      end
    }
  end

  rule instance_variable
    "@" identifier {
      def to_ast(context)
        Ddir::Ast::InstanceVariable.new name: text_value.intern
      end
    }
  end

  rule identifier
    [_a-z] [_a-zA-Z0-9]*
  end

  rule operator
    '+' / '-'
  end

  rule sp
    ' '+
  end

  rule nl
    "\n"
  end

  rule integer
    [0-9]+ {
      def to_ast(context)
        Ddir::Ast::Integer.new value: text_value.to_i
      end
    }
  end

  rule symbol
    ':' value:[_a-zA-Z0-9]+ {
      def to_ast(context)
        Ddir::Ast::Symbol.new value: value.text_value.intern
      end
    }
  end
end
