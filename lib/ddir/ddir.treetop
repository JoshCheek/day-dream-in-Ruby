require 'treetop/runtime'

grammar DayDreamInRuby
  rule body
    exprs:expressions {
      def to_ast
        Ddir::Ast::Body.new exprs.to_ast
      end
    }
  end

  rule expressions
    (sp? expression sp? nl?)* {
      def to_ast
        if elements.size == 1
          elements.first.expression.to_ast
        else
          Ddir::Ast::Expressions.new \
            elements.map { |el| el.expression.to_ast }
        end
      end
    }
  end

  rule expression
    head:(entry_location / variable / self / integer)
    tail:expression_modifiers* {
      def to_ast
        tail.elements.inject head.to_ast do |ast, modifier|
          modifier.to_ast ast
        end
      end
    }
  end

  rule expression_modifiers
    ( (sp? modifier:binary_op_call)
    / (    modifier:send_message)
    ) {
      def to_ast(to_modify)
        modifier.to_ast to_modify
      end
    }
  end

  rule send_message
    "." name:identifier args:(sp expression)* sp? maybe_block:block? {
      def to_ast(receiver)
        Ddir::Ast::SendMessage.new \
          receiver,
          name.text_value.intern,
          args.elements.map { |arg| arg.expression.to_ast },
          (maybe_block.to_ast unless maybe_block.empty?)
      end
    }
  end

  rule block
    '(' params ')' sp? body:expression? {
      def to_ast
        body_ast = body.empty? ? Ddir::Ast::None.new : body.to_ast
        Ddir::Ast::Block.new params.ordered_names,
                             body_ast
      end
    }
  end

  rule params
    first_name:local_variable?
    remaining_names:(sp? ',' sp? local_variable)* {
      def ordered_names
        names = []
        names << first_name.text_value.intern unless first_name.empty?
        remaining_names.elements.each { |n| names << n.local_variable.text_value.intern }
        names
      end
    }
  end

  rule entry_location
    '->' sp? door:(expression / block) {
      def to_ast
        Ddir::Ast::EntryLocation.new door.to_ast
      end
    }
  end

  rule binary_op_call
    operator sp? rhs:expression {
      def to_ast(lhs)
        Ddir::Ast::BinaryExpression.new lhs,
                                        operator.text_value,
                                        rhs.to_ast
      end
    }
  end

  rule self
    "@" {
      def to_ast
        Ddir::Ast::Self.new
      end
    }
  end

  rule variable
    variable:(local_variable / instance_variable) {
      def to_ast
        variable.to_ast
      end
    }
  end

  rule local_variable
    identifier {
      def to_ast
        Ddir::Ast::LocalVariable.new text_value.intern
      end
    }
  end

  rule instance_variable
    "@" identifier {
      def to_ast
        Ddir::Ast::InstanceVariable.new text_value.intern
      end
    }
  end

  rule identifier
    [_a-z]+
  end

  rule operator
    '+' / '-'
  end

  rule sp
    ' '+
  end

  rule nl
    "\n"
  end

  rule integer
    [0-9]+ {
      def to_ast
        Ddir::Ast::Integer.new text_value.to_i
      end
    }
  end
end
