require 'treetop/runtime'

grammar DayDreamInRuby
  rule body
    exprs:expressions {
      def to_ast
        Ddir::Ast::Body.new exprs.to_ast
      end
    }
  end

  rule expressions
    (sp? expression sp? nl?)* {
      def to_ast
        if elements.size == 1
          elements.first.expression.to_ast
        else
          Ddir::Ast::Expressions.new \
            elements.map { |el| el.expression.to_ast }
        end
      end
    }
  end

  rule expression
    head:(entry_location / variable / self / integer / symbol)
    tail:expression_modifiers* {
      def to_ast
        tail.elements.inject head.to_ast do |ast, modifier|
          modifier.to_ast ast
        end
      end
    }
  end

  rule expression_modifiers
    ( (sp?        modifier:binary_op_call)
    / (           modifier:send_assignemnt_message)
    / (           modifier:send_message)
    / (sp?        modifier:assignment)
    / (sp? nl sp? modifier:send_message)
    ) {
      def to_ast(to_modify)
        modifier.to_ast to_modify
      end
    }
  end

  rule assignment
    '<-' sp? value:expression {
      def to_ast(target_ast)
        Ddir::Ast::Assignment.new target_ast, value.to_ast
      end
    }
  end

  rule send_assignemnt_message
    '.' name:identifier sp? assignment {
      def to_ast(receiver_ast)
        Ddir::Ast::SendMessage.new \
          receiver_ast,
          :"#{name.text_value}=",
          [assignment.value.to_ast], # args
          nil                        # no block
      end
    }
  end

  rule send_message
    "." name:identifier args:(sp expression)* sp? maybe_block:block? {
      def to_ast(receiver_ast)
        Ddir::Ast::SendMessage.new \
          receiver_ast,
          name.text_value.intern,
          args.elements.map { |arg| arg.expression.to_ast },
          (maybe_block.to_ast unless maybe_block.empty?)
      end
    }
  end

  rule block
    '(' params ')' nl sp  body:expressions {
      def to_ast
        Ddir::Ast::Block.new params.ordered_names, body.to_ast
      end
    }
    /
    nl sp body:expressions {
      def to_ast
        Ddir::Ast::Block.new [], body.to_ast
      end
    }
    /
    '(' params ')' sp? body:expression?  {
      def to_ast
        body_ast = body.empty? ? Ddir::Ast::None.new : body.to_ast
        Ddir::Ast::Block.new params.ordered_names, body_ast
      end
    }
  end

  rule params
    first_name:local_variable?
    remaining_names:(sp? ',' sp? local_variable)* {
      def ordered_names
        names = []
        names << first_name.text_value.intern unless first_name.empty?
        remaining_names.elements.each { |n| names << n.local_variable.text_value.intern }
        names
      end
    }
  end

  rule entry_location
    '->' sp? name:symbol? sp? body:block {
      def to_ast
        name_symbol = name.empty? ? :call : name.to_ast.value
        Ddir::Ast::EntryLocation.new name_symbol, body.to_ast
      end
    }
  end

  rule binary_op_call
    operator sp? rhs:expression {
      def to_ast(lhs)
        Ddir::Ast::BinaryExpression.new lhs,
                                        operator.text_value,
                                        rhs.to_ast
      end
    }
  end

  rule self
    "@" {
      def to_ast
        Ddir::Ast::Self.new
      end
    }
  end

  rule variable
    variable:(local_variable / instance_variable) {
      def to_ast
        variable.to_ast
      end
    }
  end

  rule local_variable
    identifier {
      def to_ast
        Ddir::Ast::LocalVariable.new text_value.intern
      end
    }
  end

  rule instance_variable
    "@" identifier {
      def to_ast
        Ddir::Ast::InstanceVariable.new text_value.intern
      end
    }
  end

  rule identifier
    [_a-z] [_a-zA-Z0-9]*
  end

  rule operator
    '+' / '-'
  end

  rule sp
    ' '+
  end

  rule nl
    "\n"
  end

  rule integer
    [0-9]+ {
      def to_ast
        Ddir::Ast::Integer.new text_value.to_i
      end
    }
  end

  rule symbol
    ':' value:[_a-zA-Z0-9]+ {
      def to_ast
        Ddir::Ast::Symbol.new value.text_value.intern
      end
    }
  end
end
