require 'treetop/runtime'

grammar DayDreamInRuby
  rule body
    exprs:expressions {
      def to_ast(context)
        Ddir::Ast::Body.new expressions: exprs.to_ast(context)
      end
    }
  end

  rule expressions
    ( indentation matched:(
        expression:expression {
          def declare_ast(context, depth)
            context.add_child depth, expression.to_ast(context)
          end
        }
        /
        modifier:expression_modifier {
          def declare_ast(context, depth)
            context.modify depth do |ast|
              modifier.to_ast context, ast
            end
          end
        }
        /
        nl {
          def declare_ast(context, depth)
            # noop (allows empty lines)
          end
        }
        /
        '#' [^\n]* {
          def declare_ast(context, depth)
            # ideally we would push these through,
            # but that would make generation hard,
            # and this project is mostly just a thought experiment
          end
        }
      ) sp? nl?)* {
      def to_ast(context)
        context.push_expressions do
          elements.each { |el|
            # if the indentation increased
            # then it is a child of the last element, which is expected to be a block
            el.matched.declare_ast context, el.indentation.depth
          }
        end
      end
    }
  end

  rule indentation
    ' '* {
      def depth
        text_value.length / 2
      end
    }
  end

  rule expression
    head:(entry_location / variable / self / integer / symbol)
    tail:expression_modifier* {
      def to_ast(context)
        tail.elements.inject head.to_ast(context) do |ast, modifier|
          modifier.to_ast context, ast
        end
      end
    }
  end

  rule expression_modifier
    sp? modifier:(
      binary_op_call
    / send_assignemnt_message
    / send_message
    / assignment
    ) {
      def to_ast(context, to_modify)
        modifier.to_ast context, to_modify
      end
    }
  end

  rule assignment
    '<-' sp? value:expression {
      def to_ast(context, target_ast)
        Ddir::Ast::Assignment.new target: target_ast, value: value.to_ast(context)
      end
    }
  end

  rule send_assignemnt_message
    '.' name:identifier sp? assignment {
      def to_ast(context, receiver_ast)
        Ddir::Ast::SendMessage.new \
          depth:     context.depth,
          receiver:  receiver_ast,
          name:      :"#{name.text_value}=",
          arguments: [assignment.value.to_ast(context)],
          block:     nil
      end
    }
  end

  rule send_message
    "." name:identifier suffix:('!' / '?' / '') args:(sp expression)* sp? maybe_block:block? {
      def to_ast(context, receiver_ast)
        Ddir::Ast::SendMessage.new \
          depth:     context.depth,
          receiver:  receiver_ast,
          name:      (name.text_value + suffix.text_value).intern,
          arguments: args.elements.map { |arg| arg.expression.to_ast context },
          block:     (maybe_block.to_ast context unless maybe_block.empty?)
      end
    }
  end

  rule block
    '(' params ')' sp? body:expression?  {
      def to_ast(context)
        Ddir::Ast::Block.new \
          depth:       context.depth,
          param_names: params.ordered_names,
          body:        (body.to_ast context unless body.empty?)
      end
    }
  end

  rule params
    first_name:local_variable?
    remaining_names:(sp? ',' sp? local_variable)* {
      def ordered_names
        names = []
        names << first_name.text_value.intern unless first_name.empty?
        remaining_names.elements.each { |n| names << n.local_variable.text_value.intern }
        names
      end
    }
  end

  rule entry_location
    '->' sp? name:symbol? sp? body:block? {
      def to_ast(context)
        name_symbol = name.empty? ? :call : name.to_ast(context).value
        Ddir::Ast::EntryLocation.new \
          depth: context.depth,
          name:  name_symbol,
          body:  (body.to_ast(context) unless body.empty?)
      end
    }
  end

  rule binary_op_call
    operator sp? rhs:expression {
      def to_ast(context, lhs)
        Ddir::Ast::BinaryExpression.new left_child:  lhs,
                                        operator:    operator.text_value.intern,
                                        right_child: rhs.to_ast(context)
      end
    }
  end

  rule self
    "@" {
      def to_ast(context)
        Ddir::Ast::Self.new
      end
    }
  end

  rule variable
    variable:(local_variable / instance_variable) {
      def to_ast(context)
        variable.to_ast(context)
      end
    }
  end

  rule local_variable
    identifier {
      def to_ast(context)
        Ddir::Ast::LocalVariable.new name: text_value.intern
      end
    }
  end

  rule instance_variable
    "@" identifier {
      def to_ast(context)
        Ddir::Ast::InstanceVariable.new name: text_value.intern
      end
    }
  end

  rule identifier
    [_a-z] [_a-zA-Z0-9]*
  end

  rule operator
    '+' / '-'
  end

  rule sp
    ' '+
  end

  rule nl
    "\n"
  end

  rule integer
    [0-9]+ {
      def to_ast(context)
        Ddir::Ast::Integer.new value: text_value.to_i
      end
    }
  end

  rule symbol
    ':' value:[_a-zA-Z0-9]+ {
      def to_ast(context)
        Ddir::Ast::Symbol.new value: value.text_value.intern
      end
    }
  end
end
